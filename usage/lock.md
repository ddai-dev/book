# 锁

当多个请求争抢同一资源的情况出现时，就需要使用锁来进行访问控制。

Redis 并没有直接提供锁操作原语，不过我们可以使用现有的 Redis 命令来实现一个锁。

编写锁的实现必须非常小心，因为一个不起眼的缺陷就可能导致[竞争条件](http://en.wikipedia.org/wiki/Race_condition)的发生，作为例子，稍后我们就会看到一个不正确的、带有竞争条件的锁实现。

除此之外，锁还需要一些强制机制，比如超时限制，以避免[死锁](http://en.wikipedia.org/wiki/Deadlock)。


## API

最简单的锁只有一个操作： ``acquire name timeout`` 。

``name`` 参数决定这个锁的名字，同一时间，只能有一个客户端获取这个名字的锁。

``timeout`` 参数决定加锁时间，超过这个时间之后，锁自动释放。

在一些实现中， ``timeout`` 参数并不是必须的，但是为了防止客户端在获取锁之后失败，从而导致死锁，这个实现强制使用者必须指定一个加锁时间。

上面这个锁的一个缺陷是，如果客户端并不需要占用整个加锁时间，那么其余的加锁时间就会被浪费掉。

比如说，客户端可能获取了一个 10 秒的锁，但是它只用了 5 秒就完成了工作，那么剩下的 5 秒加锁时间就被白白浪费了。这说明，我们应该再添加一个操作，使得加锁客户端可以提前释放锁：

``release`` 操作手动释放给定名称的锁，它的格式为 ``release name`` 。

> 注意
> 
> ``release`` 操作并没有进行任何形式的验证，这也意味着，任何客户端都可以调用 ``release`` 操作来释放一个给定的锁。
>
> 我们将检查释放权限的责任交给程序来执行：一个正确的程序应该保证，只有持有锁的客户端才能调用 ``release`` 操作。
>
> 如果在程序里不能保证这一点，那么可以考虑给锁加上一个 ``uid`` 参数，作为唯一标识符，并且在加锁和解锁的时候都对标识符进行验证，就像这样：
>
> ``acquire uid name timeout``
>
> ``release uid name``


## 实现

有两种方法实现锁：

第一种方法使用字符串、事务和 ``WATCH`` 命令，操作复杂，容易出错，好处是可以用于任何支持事务和 ``WATCH`` 命令的 Redis 版本（>= 2.2.0）。

第二种方法使用 Lua 脚本和字符串来实现，操作简单，但是只适用于 Redis 2.6 或以上版本。


## 使用字符串、事务和 WATCH 实现

TODO


## 使用 Lua 脚本和字符串实现

TODO


## 参考资料

[维基百科 Lock(computer science) 词条](http://en.wikipedia.org/wiki/Lock_\(computer_science\))
